#!/bin/sh

ws_message(){
    printf 'mash_ws: %s\n' "$1" >&2
}

ws_proc_main(){
    rm -f ipc/sockin
    rm -f ipc/sockout && mkfifo ipc/sockout
    url="wss://gateway.discord.gg/?v=6&encoding=json"
    nc -klU ipc/sockin | websocat -tnE -B 512000000 -S "$url" \
                       | stdbuf -o L tee ipc/control ipc/sequence \
                       >> ipc/sockout
    ws_kill 'Connection ended'
}

# shellcheck disable=SC2016
# shellcheck disable=SC2059
ws_proc_heartbeat(){
    payload="$1"
    token="$(cat config/token)"
    if [ -f stat/session ]; then
        session_id="$(cat stat/session)"
        seq="$(tail -n 1 stat/seq 2> /dev/null)"; seq="${seq:-0}"
        
        format='{"token": "%s", "session_id": "%s", "seq": %s}\n'
        printf "$format" "$token" "$session_id" "$seq" | ws_send 6
        ws_message 'Trying to resume'
    else
        prop='{"$os": "unix", "$browser": "mash", "$device": "mash"}'
        shard="[$(cat config/shard_no), $(cat config/shard_count)]"
        gs="$(cat config/guild_subscriptions)"
        intents="$(cat config/intents)"

        base='"token": "%s", "properties": %s, "shard": %s'
        base="$base, \"guild_subscriptions\": %s"
        if [ -z "$intents" ]; then
            printf "{$base}\n" "$token" "$prop" "$shard" "$gs" | ws_send 2
        else
            base="$base, \"intents\": %s"
            printf "{$base}\n" "$token" "$prop" "$shard" "$gs" \
                               "$intents" | ws_send 2
        fi
        ws_message 'Trying to login'
    fi

    ack_timeout=5
    interval=$(printf '%s\n' "$payload" | jq -r '.d|.heartbeat_interval')
    interval="$(awk "BEGIN { print ($interval / 1000) - $ack_timeout }")"
    while true; do
        seq="$(tail -n 1 stat/seq 2> /dev/null)"; seq="${seq:-0}"
        printf '%d\n' "$seq" > stat/seq

        printf '%s\n' "$seq" | ws_send 1
        sleep "$ack_timeout"
        [ ! -f stat/heartbeat ] && break
        rm stat/heartbeat

        sleep "$interval"
    done
    ws_kill 'Heartbeat ack timeout'
}

ws_proc_controller(){
    rm -f ipc/control && mkfifo ipc/control
    jq --unbuffered -cM \
    'select((.op==0 and .t=="READY") or (.op==0 and .t=="RESUMED")
     or .op==7 or .op==9 or .op==10 or .op==11)' < ipc/control \
    | while read -r payload; do
          op="$(printf '%s\n' "$payload" | jq -cM '.op')" 
          case "$op" in
          0)
              t="$(printf '%s\n' "$payload" | jq -cMr '.t')"
              case "$t" in
              READY)
                  printf '%s\n' "$payload" \
                  | jq -r '.d|.session_id' > stat/session
                  user="$(printf '%s\n' "$payload" \
                          | jq -r '.d|.user|"\(.username)#\(.discriminator)"')"
                  ws_message "Logged as $user" ;;
              RESUMED)
                  ws_message 'Resumed';;
              esac ;;
          7)
              ws_kill 'Reconnection needed' ;; 
          9) 
              rm -f stat/session
              ws_kill 'Bad session' ;;
          10)
              ws_message 'Connection established'
              ws_proc_heartbeat "$payload" &
              printf '%s\n' "$!" > proc/heartbeat ;;
          11)
              printf '%s\n' "$payload" > stat/heartbeat ;;
          esac
      done
    ws_kill 'Stream closed (controller)'
}

ws_proc_sequencer(){
    rm -f ipc/sequence && mkfifo ipc/sequence
    jq --unbuffered -r 'select(.s!=null) | .s' < ipc/sequence >> stat/seq
    ws_kill 'Stream closed (sequencer)'
}

ws_send(){
    [ -z "$1" ] && exit 1
    read -r text
    printf '{"op":%d,"d":%s}\n' "$1" "$text" | nc -U -w0 ipc/sockin
}

ws_kill(){
    [ -d proc ] || exit
    exec 3> stat/dying; flock 3

    mash_tools proc_kill \* 2> /dev/null && ws_message "$1"
    
    flock -u 3
}

ws_cleanup(){
    ws_kill 'Cleanup'
    rm -rf "$(mash_tools home)"
    exit
}

ws_start(){
    dir="$(mash_tools home)"
    rm -rf "$dir"; mkdir "$dir"

    MASH_HOME="$(realpath "$dir")"
    export MASH_HOME
    
    cd "$dir" || exit
    trap ws_cleanup INT TERM EXIT

    mkdir ipc stat lock config proc
    printf '%s\n' "$1" > config/token
    printf '%s\n' "$2" > config/bot
    printf '%s\n' "$3" > config/shard_no
    printf '%s\n' "$4" > config/shard_count
    printf '%s\n' "$5" > config/guild_subscriptions
    printf '%s\n' "$6" > config/intents

    while true; do
        ws_proc_controller &
        printf '%s\n' "$!" > proc/controller
        ws_proc_sequencer &
        printf '%s\n' "$!" > proc/sequencer
        
        while [ ! -p ipc/control ] || [ ! -p ipc/sequence ]; do
            sleep 1
        done
        
        ws_proc_main &
        printf '%s\n' "$!" > proc/main

        mash_tools new_broker

        wait
        ws_message 'Restarting...'
    done
}

ws_usage(){
    printf '%s\n' 'usage: mash_ws [OPTIONS] TOKEN' >&2
    printf '%s\n' 'Starts a session' >&2
    printf '%s\n' 'Avaliable options:' >&2
    printf '%s\n' '-u            userbot' >&2
    printf '%s\n' '-g            guild subscriptions' >&2
    printf '%s\n' '-s n/c        shard number/count (0/1)' >&2
    printf '%s\n' '-i intents    gateway intents' >&2 
    exit 1
}

err=0; bot='true'; gs='false'; shard='0/1'
while getopts 'ugs:i:' c
do
  case "$c" in
    u) bot='false' ;;
    g) gs='true' ;;
    s) shard="$OPTARG" ;;
    i) intents="$OPTARG" ;;
    \?) err=1 ;;
  esac
done

shard="$(printf '%s\n' "$shard" | grep '[0-9]\+\/[0-9]\+')"
shard_no="${shard%/*}"; shard_co="${shard#*/}"
[ "$shard_no" -eq "$shard_no" ] 2> /dev/null || err=1 
[ "$shard_co" -eq "$shard_co" ] 2> /dev/null || err=1
[ "$shard_no" -ge "$shard_co" ] 2> /dev/null && err=1

shift "$(( OPTIND - 1 ))"
[ "$#" != 1 ] && err=1 || token="$1"

if [ "$err" !=  1 ]; then
    ws_start "$token" "$bot" "$shard_no" "$shard_co" "$gs" "$intents"
else
    ws_usage
fi

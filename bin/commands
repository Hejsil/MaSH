#!/bin/bash

prefix(){
	MASH_PREFIX=( $1 )
}

dispatch(){
	eval "MASH_DISPATCH_$1='$2'"
	export "MASH_DISPATCH_$1"
}

xcommand(){
	NAMES=( $2 )
	for NAME in "${NAMES[@]}"; do
		eval "MASH_COMMAND_$NAME='$1'"
		export "MASH_COMMAND_$NAME"
		eval "MASH_COMMAND_${NAME}_CTX='$3'"
		export "MASH_COMMAND_${NAME}_CTX"
	done
}

set-args(){
	ARGS=( $@ ); JSON=''
	for ARG in "${ARGS[@]}"; do
		IFS=':' read -ra ARGSQ <<< "$ARG"
		KEY="${ARGSQ[0]}" VAR=${ARGSQ[1]:-${ARGSQ[0]}}
		[ -n "${ARGSQ[2]}" ] && VALUE="${!VAR:-null}" || VALUE="\"${!VAR}\""
		JSON="$JSON\"$KEY\":$VALUE,"
	done
	JSON="{${JSON::-1}}"; echo "$JSON" | jq -cM
}

get-args(){
	read -r JSON
	ARGS=( $@ ); RQ=''; Q=''
	for ARG in "${ARGS[@]}"; do
		IFS=':' read -ra ARGSQ <<< "$ARG"
		KEY="${ARGSQ[0]}"
		[ -n "${ARGSQ[2]}" ] && RQ="$RQ.$KEY," || Q="$Q.$KEY,"
	done

	if [ -n "$RQ" ]; then
		RQ="${RQ::-1}"; RQ="$(echo "$JSON" | jq "$RQ")"
		mapfile -t RQ <<< "$RQ"
	fi

	if [ -n "$Q" ]; then
		Q="${Q::-1}"; Q="$(echo "$JSON" | jq -r "$Q")"
		mapfile -t Q <<< "$Q"
	fi

	for ARG in "${ARGS[@]}"; do
		IFS=':' read -ra ARGSQ <<< "$ARG"
		VAR=${ARGSQ[1]:-${ARGSQ[0]}}
		if [ -n "${ARGSQ[2]}" ]; then
			VALUE="${RQ[0]}"; RQ="${RQ[@]:1}"
		else
			VALUE="${Q[0]}"; Q="${Q[@]:1}"
		fi

		echo "$VAR='$VALUE'"
	done
}

parse-commands(){
	CONTENT=$(echo "$1" | jq '.content')
	CONTENT=${CONTENT#'"'}; CONTENT=${CONTENT%'"'}
	if [ -n "$MASH_PREFIX" ]; then
		for TEST_PREFIX in "${MASH_PREFIX[@]}"; do
			if [[ "$CONTENT" == "$TEST_PREFIX"* ]]; then
				PREFIX="$TEST_PREFIX"; break
			fi
		done
	else
		exit
	fi
	[ -z "$PREFIX" ] && exit

	BOT=$(echo "$1" | jq '.author|.bot')
	[ "$BOT" == "true" ] && exit

	CONTENT=${CONTENT#$PREFIX}
	CONTENT=("${CONTENT[@]//\\\"/\"}")
	CONTENT=$(xargs printf '%s\n' <<< "$CONTENT")

	mapfile -t ARGS <<< "$CONTENT"
	ARGS=("${ARGS[@]//\"/\\\"}")

	COMMAND=${ARGS[0]}
	FUNC="MASH_COMMAND_$COMMAND"; FUNC="${!FUNC}"
	[ -z "$FUNC" ] && exit

	CTXSTR="MASH_COMMAND_${COMMAND}_CTX"; CTXSTR="${!CTXSTR}"
	CTX=$(echo "$1" | jq -r "$CTXSTR" )
	mapfile -t CTX <<< "$CTX"

	"$FUNC" "${ARGS[@]:1}"
}

parse-event(){
	T=$(echo "$1" | jq -r '.t')
	D=$(echo "$1" | jq -cM '.d')
	F="MASH_DISPATCH_$T"; F="${!F}"	
	[ -n "$F" ] && "$F" "$D"
}

bot-loop(){
	. `which env_parallel.bash`
	env_parallel parse-event "{}" < <(ws-start)
}

if [[ $_ == $0 ]]; then
	echo "Usage: source commands" >&2
	echo "Helper functions for the lib"
	echo ""
	echo "This script needs to be sourced to work properly"
	echo "The avaliable functions are listed below"
	echo ""
	echo "prefix {PREFIX}"
	echo "    Sets the bot prefix variable"
	echo "    PREFIX: A string having one or more prefixes"
	echo ""
	echo "dispatch {EVENT} {FUNCTION}"
	echo "    Defines a event dispatch route"
	echo "    EVENT: The name of the event"
	echo "    FUNCTION: The name of the function"
	echo ""
	echo "xcommand {FUNC} {NAME} {CTX_STRING}"
	echo "    Defines a command"
	echo "    FUNC: The name of the function"
	echo "    NAME: A string having one or more names"
	echo "    CTX_STRING: A jq query for the CTX variable,"
	echo "        needs to return values separated by lines"
	echo "        an example would be '.channel_id,.id'"
	echo ""
	echo "set-args {ARG1} [ARG2] ... [ARGN]"
	echo "    Creates a json object using environment"
	echo "        variables as key and values"
	echo "    ARGs: A string on the following format"
	echo "       {KEY}:[VAR]:[RAW]"
	echo "       KEY: A json key"
	echo "       VAR: A environment variable, KEY if empty"
	echo "       RAW: Empty for string, @ for raw json"
	echo ""
	echo "get-args {ARG1} [ARG2] ... [ARGN]"
	echo "    Returns an evaluable string of the keys"
	echo "        and values from JSON keys"
	echo "    ARGs: A string on the following format"
	echo "       {KEY}:[VAR]:[RAW]"
	echo "       KEY: A json key"
	echo "       VAR: A environment variable, KEY if empty"
	echo "       RAW: Empty for string, @ for raw json"
	echo ""
	echo "parse-commands {MESSAGE}"
	echo "    Parse commands from a message object"
	echo "    MESSAGE: Data from a MESSAGE_CREATE payload"
	echo ""
	echo "bot-loop [MAX_JOBS]"
	echo "    Reads the events from the websocket"
       	echo "        and dispatches them"
else
	dispatch MESSAGE_CREATE parse-commands
fi

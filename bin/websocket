#!/bin/bash
source utils
. `which env_parallel.bash`

_last-seq(){
        SEQ="$(cat "$MASH_STATUS_DIR/stat/seq_$1" 2> /dev/null)"; echo "${SEQ:-0}"
}

_dispatch-event(){
	F="$1"; PAYLOAD="$(cat "$F")"; rm -f "$F"

	OP="$(echo "$PAYLOAD" | grep -oP '(?<="op":).*?(?=,)')"
	echo "$PAYLOAD" | tee "$EWDS/"* "$EWDG/"* >> /dev/null

        case $OP in
        0)
		TSDP='(?<="t":").*?(?=",)|(?<="s":).*?(?=,)|(?<="d":).*'
        	TSD="$(echo "$PAYLOAD" | grep -oP "$TSDP" | head --bytes -2)"
        	mapfile -t TSD <<< "$TSD"
        	T="${TSD[0]}"; S="${TSD[1]}"; D="${TSD[2]}"

        	[ "$T" == 'READY' ] && (echo "$D" | jq -r '.session_id' > "$SESF")
		[[ "$S" != 'null' ]] && (echo "$S" > "$SEQF")
	
		F="MASH_DISPATCH_$T"; F="${!F}"
		[ -n "$F" ] && "$F" "$D";;
        7)
		ws-kill "$SHARD";;
        9)
        	rm -f "$SESF"; rm -f "$LOGF"
		ws-kill "$SHARD";;
        10)
		if [ -f "$SESF" ]; then
			token="$MASH_AUTH_TOKEN"
			session_id="$(cat "$SESF")"; seq="$(_last-seq "$SHARD")"
			set-args token session_id seq::@ | ws-send 6 "$SHARD"
		else
			token="$MASH_AUTH_TOKEN"
			os="linux"; browser="mash"; device="mash"; shard="[$SHARD, $SHARDS]"
			properties="$(set-args '$os:os' '$browser:browser' '$device:device')"
			set-args token properties::@ shard::@ | ws-send 2 "$SHARD"
		fi

		INTERVAL=$(echo "$PAYLOAD" | jq -r '.d|.heartbeat_interval'); WAIT=5
		INTERVAL="$(awk "BEGIN { print ($INTERVAL / 1000) - $WAIT  }")"

		while true; do
			LACK="$(date +%s%N)"
			_last-seq "$SHARD" | ws-send 1 "$SHARD"
			ACK="$(ewait '.op==11' "$WAIT" "$SHARD")"
			if [ -z "$ACK" ]; then
				ws-kill "$SHARD"; break
			fi
			sleep "$INTERVAL"
		done;;
        esac
}

_ws-shard(){
	SHARD="$1"; SHARDS="$2"
	PIPE="$MASH_STATUS_DIR/pipe/$1"
	rm -f "$PIPE"; mkfifo "$PIPE"

	PROC="$MASH_STATUS_DIR/proc/shard_$SHARD"
	SESF="$MASH_STATUS_DIR/stat/session_$1"
	SEQF="$MASH_STATUS_DIR/stat/seq_$1"
	EWDG="$MASH_STATUS_DIR/wait/@"
	EWDS="$MASH_STATUS_DIR/wait/${SHARD}"
	EVNT="$MASH_STATUS_DIR/event"
	[ ! -d "$EWDS" ] && mkdir "$EWDS"
	[ ! -d "$EVNT" ] && mkdir "$EVNT"

	URL="wss://gateway.discord.gg/?v=6&encoding=json"
	DUMMY="{\"op\":-1, \"d\":null}"; JOBS="${MASH_JOB_LIMIT:-200}"
	
	(tail -f "$PIPE" | websocat -B 67108864 -tnE "$URL" | \
	 (for x in $(seq "$JOBS"); do echo "$DUMMY"; done; cat) | \
	 while read -r E; do F="$EVNT/$(uuidgen)"; echo "$E" > "$F"; echo "$F"; done | \
	 env_parallel -j"$JOBS" --lb -q -N1 _dispatch-event) &

	echo "$!" > "$PROC"
	wait; return 1
}

_shard-loop(){
	until _ws-shard "$1" "$2"; do
		echo "Shard $1: crashed with exit code $?... Reconnecting..." >&2
		sleep 1
	done
}

ws-start(){
	if [ "$(set |(env;cat) | wc -c)" -ge 64000 ]; then
		echo "Your environment is larger than 64kB, env_parallel can't work" >&2
		echo "Don't source rest or long functions on the main script" >&2
		exit 1
	fi

	[ -z "$MASH_STATUS_DIR" ] && MASH_STATUS_DIR='.mash_tmp'
	rm -rf "$MASH_STATUS_DIR"; mkdir "$MASH_STATUS_DIR"

	mkdir "$MASH_STATUS_DIR/proc" "$MASH_STATUS_DIR/lock"
	mkdir "$MASH_STATUS_DIR/stat" "$MASH_STATUS_DIR/pipe"
	mkdir "$MASH_STATUS_DIR/wait" "$MASH_STATUS_DIR/wait/@" 

	trap "rm -rf '$MASH_STATUS_DIR'; kill 0" EXIT
	export MASH_STATUS_DIR

	[ "$MASH_AUTH_BOT" == "1" ] && SHARDS=$(echo " " | dapi GET "/gateway/bot" | jq -r '.shards//empty')
	SHARDS="${SHARDS:-1}"
	for ((I=0;I<$SHARDS;I++)); do
	       	_shard-loop "$I" "$SHARDS" &
       	done; wait
}

ws-send(){
	[ -z "$1" ] && exit 1
	read -r TEXT; PIPE="$MASH_STATUS_DIR/pipe/${2:-0}"
	echo "{\"op\":$1,\"d\":$TEXT}" | dd oflag=nonblock of="$PIPE" status=none
}

ws-kill(){
	[ -z "$1" ] && exit 1 || kill "$(cat "$MASH_STATUS_DIR/proc/shard_$1")"
}

ewait(){
	[ -z "$1" ] && exit 1
	PIPE="$MASH_STATUS_DIR/wait/${3:-@}/$(uuidgen)"
	rm -f "$PIPE"; mkfifo "$PIPE"
	tail -f > "$PIPE" &
	trap "kill -9 $! 2> /dev/null; rm -f '$PIPE'" EXIT

	QUERY="fromstream(0|truncate_stream(inputs)) | select($1)"
	while IFS= read -r EVENT || [[ -n "$EVENT" ]]; do echo "$EVENT"; exit
	done < <(timeout "${2:-0}" cat "$PIPE" | jq -cM --stream --unbuffered "$QUERY") 
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	echo "Usage: source websocket" >&2
	echo "Websocket connection and functions"
	echo ""
	echo "This script needs to be sourced to work properly"
	echo "The avaliable functions are listed below"
	echo ""
	echo "ws-start"
	echo "    Starts the ws connection and dispatch the events"
	echo "    using MASH_DISPATCH_{EVENT} environment variables"
	echo ""
	echo "ws-send {OP_CODE} [SHARD]"
	echo "    Sends the JSON data from the STDIN to the gateway"
	echo "        OP_CODE: The opcode for the operation" 
	echo "        SHARD: The shard that will send it, default is 0"
	echo ""
	echo "ws-kill {SHARD}"
	echo "    Kills a shard that will automatically restart"
	echo "        SHARD: The shard that will be killed"
	echo ""
	echo "ewait {CONDITION} [TIMEOUT] [SHARD]" >&2
       	echo "    Watches the log until it finds a event that meet "
	echo "    the jq condition, and outputs it"
	echo "        CONDITION: A Jq string that returns a boolean"
	echo "        TIMEOUT: In seconds, 0 for never expire"
	echo "        SHARD: Shard number or nothing for all shards"
fi


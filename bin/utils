#!/bin/bash

set-args(){
        ARGS=( $@ ); JSON=''
        for ARG in "${ARGS[@]}"; do
                IFS=':' read -ra ARGSQ <<< "$ARG"
                KEY="${ARGSQ[0]}" VAR=${ARGSQ[1]:-${ARGSQ[0]}}
                [ -n "${ARGSQ[2]}" ] && VALUE="${!VAR:-null}" || VALUE="\"${!VAR}\""
                JSON="$JSON\"$KEY\":$VALUE,"
        done
        JSON="{${JSON::-1}}"; echo "$JSON" | jq -cM
}

get-args(){
        read -r JSON
        ARGS=( $@ ); RQ=''; Q=''
        for ARG in "${ARGS[@]}"; do
                IFS=':' read -ra ARGSQ <<< "$ARG"
                KEY="${ARGSQ[0]}"
                [ -n "${ARGSQ[2]}" ] && RQ="$RQ.$KEY," || Q="$Q.$KEY,"
        done

        if [ -n "$RQ" ]; then
                RQ="${RQ::-1}"; RQ="$(echo "$JSON" | jq "$RQ")"
                mapfile -t RQ <<< "$RQ"
        fi

        if [ -n "$Q" ]; then
                Q="${Q::-1}"; Q="$(echo "$JSON" | jq -r "$Q")"
                mapfile -t Q <<< "$Q"
        fi

        for ARG in "${ARGS[@]}"; do
                IFS=':' read -ra ARGSQ <<< "$ARG"
                VAR=${ARGSQ[1]:-${ARGSQ[0]}}
                if [ -n "${ARGSQ[2]}" ]; then
                        VALUE="${RQ[0]}"; RQ="${RQ[@]:1}"
                else
                        VALUE="${Q[0]}"; Q="${Q[@]:1}"
                fi

                echo "$VAR='$VALUE'"
        done
}

format-args(){
	read -r PAYLOAD
	case $1 in
	'json')
		[ -n "$3" ] && EXTRA=",($3)"
		echo "$PAYLOAD" >> foda
		echo "$PAYLOAD" | jq -cMr "({$2} | with_entries(select(.value!=null)))$EXTRA" >> foda
		echo "$PAYLOAD" | jq -cMr "({$2} | with_entries(select(.value!=null)))$EXTRA";;
	'url')
		URL="$(echo "$PAYLOAD" | jq -jr "({$2} | with_entries(select(.value!=null)) | keys[] as \$k | \"\(\$k)=\(.[\$k])&\")")"
		[ -n "$URL" ] && echo "?${URL%?}" || echo ""
		[ -n "$3" ] && echo "$(echo "$PAYLOAD" | jq -r "$3")";;
	esac
}

urify(){
	read -r TEXT
	IMAGE=$(echo "$TEXT" | jq -r ".$1"); MIME=$(file -bN --mime-type "$IMAGE")
	echo "data:$MIME;base64,$(base64 -w 0 "$IMAGE")" > "$IMAGE.b64"
	TEXT=$(echo "$TEXT" | jq --rawfile img "$IMAGE.b64" ".$1 = \$img")
	rm "$IMAGE.b64"; echo "$TEXT"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        echo "Usage: source utils" >&2
        echo "Helper functions for the lib"
        echo ""
        echo "This script needs to be sourced to work properly"
        echo "The avaliable functions are listed below"
        echo ""
	echo "set-args {ARG1} [ARG2] ... [ARGN]"
        echo "    Creates a json object using environment "
        echo "    variables as key and values"
        echo "        ARGs: {KEY}:[VAR]:[RAW]"
        echo "            KEY: A json key"
        echo "            VAR: A environment variable, KEY if empty"
        echo "            RAW: Empty for string, @ for raw json"
        echo ""
        echo "get-args {ARG1} [ARG2] ... [ARGN]"
        echo "    Returns an evaluable string of the keys"
        echo "    and values from JSON keys"
        echo "        ARGs: {KEY}:[VAR]:[RAW]"
        echo "            KEY: A json key"
        echo "            VAR: A environment variable, KEY if empty"
        echo "            RAW: Empty for string, @ for raw json"
	echo ""
	echo "format-args {FORMAT} {ARGS} {EXTRA}"
	echo "    Filter unwanted args from STDIN and "
	echo "    returns only the specified to STDOUT"
	echo "        FORMAT: Output format, 'json' or 'url'"
	echo "        ARGS: Args separated by comma"
	echo "        EXTRA: A extra jq query"
	echo ""
        echo "urify {KEY}"
        echo "    Opens the filepath on a JSON value, and converts "
	echo "    it to a URI scheme. Accepts a JSON string on STDIN"
	echo "        KEY: A json key where the filepath is"
fi
